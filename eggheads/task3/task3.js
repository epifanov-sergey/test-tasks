/**
 * 3. Какая проблема может быть с этим кодом, если список очень длинный?
 * Предложите и объясните свое решение
 */
let list = readHugeList();
let nextListItem = function () {
    let item = list.pop();
    if (item) {
// ... обработка записи
        nextListItem();
    }
};


/**
 *  - Если список очень большой, то он требует много памяти для хранения элементов списка, вполне может случиться так,
 *  что у пользователя закончится память на устройстве (если дело происходит в браузере).
 *  - На обход очень длинного списка может потребоваться много времени, из-за чего будут фризы на UI.
 *  - Использование pop предполагает постоянное изменение длины массива, что влечет дополнительные затраты для среды исполнения.
 *
 *
 *  Что можно сделать:
 *  - Разбить большой список на небольшие части и обрабатывать его по частям.
 *  - Обработку кусочков делать асинхронной, чтобы не блокировать UI на время обработки списка.
 *  - Можно вынести обработку списка в воркер, чтобы не блокировать основной поток бразуера.
 *  - Из микрооптимизаций: можно заранее выделить память под фиксированное кол-во элементов и не использовать pop, а
 *  завести отдельную переменную для длины массива и использовать её для обработки элементов списка.
 */